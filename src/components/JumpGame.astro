---
// The game logic runs entirely client-side
---

<section class="mx-auto max-w-5xl px-4 py-section text-center">
  <p
    class="mb-4 text-sm text-text-secondary"
  >
    Bored? Try the jump game. Press <kbd
      class="rounded bg-surface-alt px-2 py-0.5 font-mono text-xs"
      >Space</kbd
    > or tap to play.
  </p>
  <div class="mx-auto w-full max-w-md">
    <canvas
      id="jump-game"
      width="400"
      height="150"
      class="w-full rounded-card border border-slate-200"
      tabindex="0"
      role="img"
      aria-label="A simple jump game â€” press Space or tap to make the character jump over obstacles"
    ></canvas>
    <p
      id="game-score"
      class="mt-2 font-mono text-sm text-text-secondary"
    >
      Tap / Space to start
    </p>
  </div>
</section>

<script>
  const canvas = document.getElementById('jump-game') as HTMLCanvasElement
  const ctx = canvas.getContext('2d')!
  const scoreEl = document.getElementById('game-score')!

  let player = { x: 50, y: 110, w: 20, h: 20, vy: 0, grounded: true }
  let obstacles: { x: number; w: number; h: number }[] = []
  let score = 0
  let gameRunning = false
  let animId = 0
  const gravity = 0.6
  const jumpForce = -10
  const speed = 3
  const minObstacleGap = 120 // Minimum px between obstacles
  let lastObstacleX = 0

  function reset() {
    player = { x: 50, y: 110, w: 20, h: 20, vy: 0, grounded: true }
    obstacles = []
    score = 0
    gameRunning = true
    lastObstacleX = 0
  }

  function jump() {
    if (!gameRunning) {
      reset()
      loop()
      return
    }
    if (player.grounded) {
      player.vy = jumpForce
      player.grounded = false
    }
  }

  canvas.addEventListener('click', jump)
  canvas.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault()
      jump()
    }
  })

  function loop() {
    if (!gameRunning) return
    ctx.clearRect(0, 0, canvas.width, canvas.height)

    // Detect dark mode
    const isDark = document.documentElement.classList.contains('dark')
    const fgColour = isDark ? '#F1F5F9' : '#1E293B'

    // Player
    player.vy += gravity
    player.y += player.vy
    if (player.y >= 110) {
      player.y = 110
      player.vy = 0
      player.grounded = true
    }
    ctx.fillStyle = '#6366F1'
    ctx.fillRect(player.x, player.y, player.w, player.h)

    // Obstacles
    // Lower spawn rate and enforce minimum gap
    if (
      (obstacles.length === 0 ||
        obstacles[obstacles.length - 1].x < canvas.width - minObstacleGap) &&
      Math.random() < 0.008
    ) {
      obstacles.push({ x: canvas.width, w: 15, h: 20 + Math.random() * 15 })
    }
    obstacles.forEach((obs, i) => {
      obs.x -= speed
      ctx.fillStyle = fgColour
      ctx.fillRect(obs.x, 130 - obs.h, obs.w, obs.h)
      // Collision
      if (
        player.x < obs.x + obs.w &&
        player.x + player.w > obs.x &&
        player.y + player.h > 130 - obs.h
      ) {
        gameRunning = false
        scoreEl.textContent = `Game over! Score: ${score}. Tap to restart.`
        return
      }
      if (obs.x + obs.w < 0) obstacles.splice(i, 1)
    })

    // Ground
    ctx.strokeStyle = fgColour
    ctx.beginPath()
    ctx.moveTo(0, 130)
    ctx.lineTo(canvas.width, 130)
    ctx.stroke()

    score++
    scoreEl.textContent = `Score: ${score}`

    if (gameRunning) animId = requestAnimationFrame(loop)
  }
</script>
